# ODRL policy in ttl format corresponding. This policy matches the simplified
# LMB authorisation policy in the lisp file.
@prefix ext: <http://mu.semte.ch/vocabularies/ext/>.
@prefix odrl: <http://www.w3.org/ns/odrl/2/>.
@prefix dct: <http://purl.org/dc/terms/>.
@prefix vcard: <http://www.w3.org/2006/vcard/ns#>.
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>.
@prefix mandaat: <http://data.vlaanderen.be/ns/mandaat#>.
@prefix skos: <http://www.w3.org/2004/02/skos/core#>.
@prefix sh: <http://www.w3.org/ns/shacl#>.
@prefix lmb: <http://lblod.data.gift/vocabularies/lmb/>.
@prefix besluit: <http://data.vlaanderen.be/ns/besluit#>.
@prefix regorg: <http://www.w3.org/ns/regorg#>.
@prefix persoon: <http://data.vlaanderen.be/ns/persoon#>.

# TODO: Extend with extra `ext:*` elements?
ext:muAuthProfile a odrl:Profile ;
  dct:description "ODRL profile describing access to mu-auth resources." .

ext:examplePolicyLMB a odrl:Set ;
  odrl:profile ext:muAuthProfile ;
  odrl:permission ext:allowReadForPublic ,
    ext:allowReadForMandatarisOrg ,
    ext:allowWriteForMandatarisOrg ,
    ext:allowReadForVendorOnMandatarisOrg ,
    ext:allowReadForPoliceCouncilOnMandatarisOrg ,
    ext:allowReadForAuthenticatedOnViewOnlyModules .

# parties
ext:lmbSystem a odrl:Party ;
  vcard:fn "LMB System" ;
  # no query here so no users match
  # TODO: Use sparql-parser's 'NEVER' constraint to ensure group is not used in
  # configuration?
  dct:description "The LMB system party used as an assigner of the permission in this profile" .

ext:publicParty a odrl:PartyCollection ;
  vcard:fn "Public user" ;
  # NOTE (20/08/2025): Ideally it should not be necessary to add this as it will
  # not be used in the sparql-parser configuration. Is it necessary to
  # differentiate between this case, which is "all users", and the above system
  # party, which is "no users"?
  #
  # this query matches every session and has no parameters
  ext:definedBy """
  PREFIX ext: <http://mu.semte.ch/vocabularies/ext/>
  PREFIX muAccount: <http://mu.semte.ch/vocabularies/account/>
  PREFIX mu: <http://mu.semte.ch/vocabularies/core/>
  SELECT DISTINCT * WHERE {
    VALUES ?session {
      <SESSION_ID>
    }
    ?session a ?thing .
  }
  """ ;
  dct:description "This party represent all (possibly not logged in) users of the system." .

ext:authenticatedParty a odrl:PartyCollection ;
  vcard:fn "Authenticated user" ;
  # no `ext:queryParameters` as they will not be used for this party
  ext:definedBy """
  PREFIX ext: <http://mu.semte.ch/vocabularies/ext/>
  PREFIX mu: <http://mu.semte.ch/vocabularies/core/>
  SELECT DISTINCT ?session_group ?session_role WHERE {
    <SESSION_ID> ext:sessionGroup/mu:uuid ?session_group ;
                 ext:sessionRole ?session_role .
  }
  """ ;
  dct:description "This represents all logged in users of the system." .

ext:mandaatGebruikerParty a odrl:PartyCollection ;
  vcard:fn "Mandaten users" ;
  ext:definedBy """
  PREFIX ext: <http://mu.semte.ch/vocabularies/ext/>
  PREFIX mu: <http://mu.semte.ch/vocabularies/core/>
  SELECT DISTINCT ?session_group ?session_role WHERE {
    <SESSION_ID> ext:sessionGroup/mu:uuid ?session_group ;
                  ext:sessionRole ?session_role .
    FILTER( ?session_role = \"LoketLB-mandaatGebruiker\" )
  }
  """ ;
  ext:queryParameters "session_group", "session_role" ;
  dct:description "This party collection represents all users who received the LoketLB-mandaatGebruiker role through ACM/IDM" .

ext:vendorGebruikerParty a odrl:PartyCollection ;
  vcard:fn "Vendor users" ;
  ext:definedBy """
  PREFIX ext: <http://mu.semte.ch/vocabularies/ext/>
  PREFIX muAccount: <http://mu.semte.ch/vocabularies/account/>
  PREFIX mu: <http://mu.semte.ch/vocabularies/core/>
  SELECT DISTINCT ?session_group ?session_role WHERE {
    VALUES ?session {
      <SESSION_ID>
    }
    {{
      ?session muAccount:canActOnBehalfOf/mu:uuid ?session_group ;
                    muAccount:account/ext:sessionRole ?session_role .
    } UNION {
      ?session muAccount:account ?account .
      ?session muAccount:canActOnBehalfOf/ext:isOCMWVoor/mu:uuid ?session_group ;
                              muAccount:account/ext:sessionRole ?session_role .
      ?session muAccount:canActOnBehalfOf/ext:isOCMWVoor/^<http://lblod.data.gift/vocabularies/lmb/heeftBestuurseenheid>/<http://lblod.data.gift/vocabularies/lmb/hasStatus> <http://data.lblod.info/id/concept/InstallatievergaderingStatus/a40b8f8a-8de2-4710-8d9b-3fc43a4b740e> .
      VALUES ?account {
        <http://data.lblod.info/vendors/14db001d-ea0f-4a8a-8453-c48547347588> # Cipal
        <http://data.lblod.info/vendors/42edb420-08c7-4ede-9961-bc0e527d0f3b> # Green Valley
        <http://data.lblod.info/vendors/dc62419e-1267-44e7-9562-0114e2708b6f> # Remmicom
      }
    }}
  }
  """ ;
  ext:queryParameters "session_group", "session_role" ;
  dct:description "This party collection represents all users who can access the information regarding communes or OCMWs through their vendor api key" .

ext:policeCouncilParty a odrl:PartyCollection ;
  vcard:fn "Politieraad lezer" ;
  ext:definedBy """
  PREFIX ext: <http://mu.semte.ch/vocabularies/ext/>
  PREFIX mu: <http://mu.semte.ch/vocabularies/core/>
  SELECT DISTINCT ?session_group ?session_role WHERE {
    <SESSION_ID> ext:sessionGroup ?original_session_group ;
                  ext:sessionRole ?session_role .
    ?original_session_group ext:deeltBestuurVan/mu:uuid ?session_group .

    FILTER( ?session_role = \"LoketLB-mandaatGebruiker\" )
  }
  """ ;
  ext:queryParameters "session_group", "session_role" ;
  dct:description "This party collection represents all users who can access the information regarding police council mandates. This is defined by the members of communes that share the control of this police council." .


# graphs
ext:lmbPublicSlice a odrl:AssetCollection ;
  vcard:fn "public" ;
  # no query parameters added to the group so the graph is exactly this uri
  ext:graphPrefix <http://mu.semte.ch/graphs/public> ;
  ext:shaclShape ext:lmbPublicShape ;
  dct:description "This asset collection contains all information that is available to the public in the context of the LMB app." .

ext:lmbAuthenticatedPublicSlice a odrl:AssetCollection ;
  vcard:fn "view-only-modules" ;
  ext:graphPrefix <http://mu.semte.ch/graphs/authenticated/public> ;
  ext:shaclShape ext:lmbAuthenticatedPublicShape ;
  dct:description "This asset collection contains all information that is available to all authenticated users in the context of the LMB app." .

ext:lmbOrganizationMandatesSlice a odrl:AssetCollection ;
vcard:fn "organization-mandatendatabank" ;
  ext:graphPrefix <http://mu.semte.ch/graphs/organizations/> ;
  # TODO: Can we avoid having to specify these parameters again?
  ext:queryParameters "session_group", "session_role" ;
  ext:shaclShape ext:lmbMandatarisShape ;
  dct:description "This asset collection contains all information that is available to users with the LoketLB-mandaatGebruiker role in the context of the LMB app." .


# rules
ext:allowReadForPublic a odrl:Permission ;
  odrl:action odrl:read ;
  odrl:target ext:lmbPublicSlice ;
  # NOTE (20/08/2025): For the transformation to sparql-parser we can ignore
  # this the `odrl:assigner` property. It is an optional property for
  # `odrl:Permission`s and as sparql-parser has no such notion it will not be
  # used in the generated configuration.
  odrl:assigner ext:lmbSystem ;
  odrl:assignee ext:publicParty .

ext:allowReadForAuthenticatedOnViewOnlyModules a odrl:Permission ;
  odrl:action odrl:read ;
  odrl:target ext:lmbAuthenticatedPublicSlice ;
  odrl:assignee ext:authenticatedParty .

# NOTE (20/08/2025): ODRL requires exactly 1 action per Rule (Permission). So
# read and write access must be specified with separate permissions. The
# transformation to sparql-parser will probably have to merge these to a single
# grant with read and write rights.
ext:allowReadForMandatarisOrg a odrl:Permission ;
  odrl:action odrl:read ;
  odrl:target  ext:lmbOrganizationMandatesSlice ;
  odrl:assigner ext:lmbSystem ;
  odrl:assignee ext:mandaatGebruikerParty .

ext:allowWriteForMandatarisOrg a odrl:Permission ;
  # NOTE (19/08/2025): Strictly speaking `odrl:modify` does *not* cover the
  # creation of new assets, new assets can be `odrl:extract`ed or `odrl:derive`d
  # from existing ones. But creating a completely new asset does not seem to be
  # covered by ODRL.
  odrl:action odrl:modify ; # NOTE (13/08/2025): The `odrl:write` property was deprecated in favour of `odrl:modify`
  odrl:target ext:lmbOrganizationMandatesSlice;
  odrl:assigner ext:lmbSystem ;
  odrl:assignee ext:mandaatGebruikerParty .

ext:allowReadForVendorOnMandatarisOrg a odrl:Permission ;
  odrl:action odrl:read ;
  odrl:target ext:lmbOrganizationMandatesSlice ;
  odrl:assigner ext:lmbSystem ;
  odrl:assignee ext:vendorGebruikerParty .

ext:allowReadForPoliceCouncilOnMandatarisOrg a odrl:Permission ;
  odrl:action odrl:read ;
  odrl:target ext:lmbOrganizationMandatesSlice ;
  odrl:assigner ext:lmbSystem ;
  odrl:assignee ext:policeCouncilParty .


# shapes
## public shape
ext:lmbPublicShape a sh:NodeShape ;
  # showing only a few types to keep the sample small
  sh:or (
    [
    # ("ext:GeslachtCode" -> _)
      sh:targetClass ext:GeslachtCode ;
    ]
    [
    # Fictional example for a shape where the predicates matter. Users can
    # access only `skos:inScheme`, `skos:prefLabel`, and `rdf:type` triples for
    # `skos:ConceptScheme` resources.
    # ("skos:ConceptScheme" -> "skos:inScheme"
    #                       -> "skos:prefLabel"
    #                       -> "rdf:type")
      sh:targetClass skos:ConceptScheme ;
      sh:property [
        sh:path skos:inScheme ;
        sh:minCount 0 # NOTE (19/08/2025): What is the added value of this for generating authz rules?
      ], [
        sh:path skos:prefLabel ;
        sh:minCount 0
      ], [
        sh:path rdf:type ;
        sh:minCount 0
      ]
    ]
    [
    # Fictional example to illustrate an inverse predicate specification. Users
    # can access all triples with a `besluit:Bestuurseenheid` as object.
    # ("besluit:Bestuurseenheid" <- _)
      sh:targetClass besluit:Bestuurseenheid ;
      sh:property [
        sh:path [ sh:inversePath ext:all ] # define custom predicate that should be interpreted as sparql-parser's `_`
      ]
    ]
    [
    # Fictional example to illustrate a selective inverse predicate
    # specification. For `skos:Concept` resources users can only access
    # `regorg:orgStatus` and `lmb:InstallatievergaderingStatus` triples in such
    # a resource is the object.
    # ("skos:Concept" <- "regorg:orgStatus"
    #                 <- "lmb:InstallatievergaderingStatus")
      sh:targetClass skos:Concept ;
      sh:property [
        sh:path [ sh:inversePath regorg:orgStatus ]
      ], [
        sh:path [ sh:inversePath lmb:InstallatievergaderingStatus]
      ]
    ]
  ).

## authenticated public shape
ext:lmbAuthenticatedPublicShape a sh:NodeShape ;
  sh:targetClass besluit:Bestuurseenheid ;
  sh:property [ sh:path ext:viewOnlyModules ] .

## mandate shape
ext:lmbMandatarisShape a sh:NodeShape ;
  # showing only a few types to keep the sample small
  sh:or (
    [
    # ("mandaat:Mandataris" -> _)
      sh:targetClass mandaat:Mandataris
    ]
    [
    # ("mandaat:Fractie" -> _)
      sh:targetClass mandaat:Fractie
    ]
    [
    # Fictional example to illustrate a disallow predicate specification. Users
    # can access everything for a `persoon:Persoon` except their
    # `persoon:registratie`.
    # ("persoon:Persoon" x> "persoon:registratie")
      sh:targetClass persoon:Persoon ;
      sh:not [
        sh:property [
          sh:path persoon:registratie
        ]
      ]
    ]
    [
    # Fictional example to illustrate a disallow predicate specification with
    # multiple predicates. Users can access everything for a `persoon:Persoon`
    # except their `persoon:registratie` or `persoon:heeftGeboorte`.
    # ("persoon:Persoon" x> "persoon:registratie"
    #                    x> "persoon:heeftGeboorte")
      sh:targetClass persoon:Persoon ;
      sh:not [
        sh:property [
          sh:path persoon:registratie
        ], [
          sh:path persoon:heeftGeboorte
        ]
      ]
    ]
    [
    # Fictional example to illustrate a disallow inverse predicate
    # specification. Users cannot access `mandaat:isBestuurlijkeAliasVan`
    # triples with a `persoon:Persoon` as object.
    # ("persoon:Persoon" <x "mandaat:isBestuurlijkeAliasVan")
      sh:targetClass persoon:Persoon ;
      sh:not [
        sh:property [
          sh:path [ sh:inversePath mandaat:isBestuurlijkeAliasVan ]
        ]
      ]
    ]
  ).
